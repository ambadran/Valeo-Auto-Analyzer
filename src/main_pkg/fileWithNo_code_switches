/* ********************************************************************** *//* Sourcefile: Idp.c                                                      *//*                                                                        *//* Department: VSeA R&D SWENG OPS 1 OP                                    *//*                                                                        *//* SW version:                                                            *//*   swc_major_version=01                                                 *//*   swc_minor_version=10                                                 *//*                                                                        *//*                                                                        *//* ********************************************************************** *//* Copyright (C) Valeo Siemens eAutomotive Germany GmbH 2022              *//* All Rights Reserved.  Confidential                                     *//* ********************************************************************** *//*! * \defgroup   IDP * Provides diagnostic data, which can be transfered * via CAN bus (e.g. with UDS 0x22) * @{ *//*================== [includes] =============================================*//*! \misra PRQA 0380 "Number of included macro definitions cannot be easily reduced, build environment can handle moremacro definitions than 4095 without issue." */#include "Rte_Idp.h" /*PRQA S 0380*/#include "Idp.h"#include "swid.h" /* EcuProdDataParamOem */#include "psr.h" /* BUS Knockout data */#include "rsh.h" /* Programming preconditions */#include "NvM_include.h"#include "NVM_SMs.h"#include "Obd.h"  /* Production mode data */#include "DcmExt.h" /* For variable DID_0410_BootloaderTPBlocksize */#include "DidUtil.h"#include "BswErrDeb.h"#include "bootifc.h"#include "adminTable.h"#include "C2cComSftyData.h" /* DID F1B8 */#include "AbcDefs.h"/*================== [defines] ==============================================*/#define UCB_IFX_ADDRESS                0xAF101000UL#define DID_PARAM_NOT_IMPLEMENTED      (0x00U)#define ECU_KNOCKOUT_TMR_BITMASK       ((uint8)0x3FU)#define BUS_KNOCKOUT_TMR_BITMASK       ((uint8)0x3FU)#define NVEM_KNOCKOUT_TMR_BITMASK      ((uint8)0x01U)/*================== [type definitions] =====================================*//*================== [local data] ===========================================*//*! \misra PRQA 4800 "This define automatically generated" */#define Idp_START_SEC_CONST_GLOBAL /* PRQA S 4800 */#include "Idp_MemMap.h"STATIC CONST (uint16, IDP_VAR) DID_040F_VWLogicalSoftwareBlockLockValue_Default[NUMBER_OF_SOFTWARE_BLOCKS-1U] ={   LOCKVALUE_DEFAULT, /* block 1 */   LOCKVALUE_DEFAULT, /* block 2 */   LOCKVALUE_DEFAULT, /* block 3 */   LOCKVALUE_DEFAULT, /* block 4 */}; /* -1 due to DownGradeProtection */STATIC CONST (TechnicalSpecificationVersionType, IDP_VAR)  F1B4_TechnicalSpecificationVersion ={         { 5U, 8U },/* Ver_80114 */         { 2U, 8U },/* Ver_80124 */         { 5U, 8U },/* Ver_80125 */         { 2U, 9U },/* Ver_80126 */         { 5U, 8U },/* Ver_80127 */         { 4U, 5U },/* Ver_80128 */         { 0U, 0U },/* Ver_DSDL */         { 0U, 0U },/* Ver_DUL */         { 2U, 1U },/* Ver_SFD */         { 0U, 0U },/* Ver_SWAP */         { 1U, 7U },/* Ver_ORU */         { 9U, 1U },/* Ver_PMode */         { 1U, 18U } /* Ver_WKMS */};/*SWID_timestamp*/STATIC CONSTP2CONST(uint8, AUTOMATIC, IDP_VAR) SysSuppEcuSwNum_ptr = SWIDStamp.SWID_timestamp;/*SWID_calibset*/STATIC CONSTP2CONST(uint8, AUTOMATIC, IDP_VAR) SysSuppEcuSwVerNum_ptr = SWIDStamp.SWID_calibset;STATIC CONST (uint8, IDP_VAR) DID_F1B6_Systemidentification[DID_F1B6_SYSTEMIDENTIFICATION_SIZE] =                              {ECU_ID_HIB, ECU_ID_LOB, NODE_ADDR_HIB, NODE_ADDR_LOB};CONST (Idp_ElectricDriveAssemblySerialNumber_NVM_ArrayType, IDP_VAR) ElectricDriveAssembly_InitValues =                                         {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                          DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                          DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                          DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                          DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                          DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                          DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/* change request: VWMEB-Inv-207330 * DID length changed to 20, NVM block size remains 21 to preserve NVM layout. * The DCM-generated array type must not be used, as it is 20 bytes long, * and NVM read will write the 21th element too.*/CONST (Idp_TransmissionHousingSerialNumber_NVM_ArrayType, IDP_VAR) TransmissionHousing_InitValues =                                          {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/* change request: VWMEB-Inv-207330 */CONST (Idp_ElectricDriveMotorSerialNumber_NVM_ArrayType, IDP_VAR) ElectricDriveMotor_InitValues =                                          {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/* change request: VWMEB-Inv-207330 */CONST (Dcm_Datax0903_Expected_model_type_ArrayType, IDP_VAR) Idp_ExpectedModelType_init={EXPECTED_MODEL_INIT_VALUE};CONST (Dcm_DataF1A0_VWDataSetNumberOrECUDataContainerNumber_ArrayType, IDP_VAR) DID_F1A0_VwDataSetVersionNumber_init =                                          {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                           DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};CONST (Dcm_DataF1A1_VWDataSetVersionNumber_ArrayType, IDP_VAR) DID_F1A1_VWDataSetVersionNumber_init =                                                 {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                                  DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_STOP_SEC_CONST_GLOBAL /* PRQA S 4800 */#include "Idp_MemMap.h"/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_START_SEC_BSW_VAR_CALIB /* PRQA S 4800 */#include "Idp_MemMap.h"/* @@ SYMBOL = F197_VWSystemNameOrEngine @@ A2L_TYPE = STRING 13 @@ DESCRIPTION = "F197 VWSystemNameOrEngine" @@ GROUP = IDP @@ END */STATIC CONST (uint8, IDP_VAR) F197_VWSystemNameOrEngine[DID_F197_VWSYSTEMNAME_SIZE] =   {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,    DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,    DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/* @@ SYMBOL = F1AD_EngineCodeLetters @@ A2L_TYPE = STRING 4 @@ DESCRIPTION = "F1AD EngineCodeLetters" @@ GROUP = SWID @@ END */STATIC CONST(uint8, IDP_VAR) F1AD_EngineCodeLetters[DID_F1AD_ENGINECODELETTERS_SIZE] =   {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_STOP_SEC_BSW_VAR_CALIB /* PRQA S 4800 */#include "Idp_MemMap.h"/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_START_SEC_BSW_VAR_CLEARED_LOCAL_UNSPECIFIED /* PRQA S 4800 */#include "Idp_MemMap.h"VAR(vagbl_nvm_data_t, IDP_VAR) VAG_BL_BlockNvData_store;VAR(vagbl_nvm_data_t, IDP_VAR) VAG_BL_BlockNvData_run;/*! \misra PRQA 2021 "This tentative definition is intended" */VAR(Idp_ElectricDriveAssemblySerialNumber_NVM_ArrayType, IDP_VAR) ElectricDriveAssemblySerialNumber; /* PRQA S 2021 *//*! \misra PRQA 2021 "This tentative definition is intended" */VAR(Idp_TransmissionHousingSerialNumber_NVM_ArrayType, IDP_VAR) TransmissionHousingSerialNumber; /* PRQA S 2021 *//*! \misra PRQA 2021 "This tentative definition is intended" */VAR(Idp_ElectricDriveMotorSerialNumber_NVM_ArrayType, IDP_VAR) ElectricDriveMotorSerialNumber; /* PRQA S 2021 *//* change request: VWMEB-Inv-207330 *//*! \misra PRQA 4800 "This define automatically generated" */#define Idp_STOP_SEC_BSW_VAR_CLEARED_LOCAL_UNSPECIFIED  /* PRQA S 4800 */#include "Idp_MemMap.h"/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_START_SEC_BSW_VAR_INIT_LOCAL_UNSPECIFIED  /* PRQA S 4800 */#include "Idp_MemMap.h"STATIC VAR(uint16, IDP_VAR) DID_040F_VWLogicalSoftwareBlockLockValue[NUMBER_OF_SOFTWARE_BLOCKS-1U] ={   0x0000U, /* block 1 */   0x0000U, /* block 2 */   0x0000U, /* block 3 */   0x0000U, /* block 4 */}; /* -1 due to DownGradeProtection *//* -1 due to DownGradeProtection */STATIC VAR(FigerprintAndPrgDateOfLogicalSwBlockType, IDP_VAR) F15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks                                                                                       [NUMBER_OF_SOFTWARE_BLOCKS-1U] ={   {{0U,0U,0U},{0U,0U,0U,0U,0U,0U},0U},   {{0U,0U,0U},{0U,0U,0U,0U,0U,0U},0U},   {{0U,0U,0U},{0U,0U,0U,0U,0U,0U},0U},   {{0U,0U,0U},{0U,0U,0U,0U,0U,0U},0U}};/* -1 due to DownGradeProtection */STATIC VAR(uint8, IDP_VAR) VWLogicalSoftwareBlockVersion[DID_F1AB_LOGICALBLOCKVERSION_SIZE*                                                                                      (NUMBER_OF_SOFTWARE_BLOCKS-1U)] ={   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/* -1 due to DownGradeProtection */STATIC VAR(uint16, IDP_VAR) VWLogicalSoftwareBlockCounterOfProgrammingAttempts[NUMBER_OF_SOFTWARE_BLOCKS-1U] =                                                                                                {0U,0U,0U,0U};STATIC VAR(uint8, IDP_VAR) DID_0102_BasicSettingsStatus = ROUTINE_CTRLS_NOT_ACTIVE;STATIC VAR(uint8, IDP_VAR) DID_02B3_ResponseOnEvent = RESPONSE_ON_EVENT_NOT_ACTIVE;/*! \misra PRQA 1504 "The variable used in other component too" */VAR(uint8, IDP_VAR) DID_F1A0_VwDataSetVersionNumber[DID_F1A0_VWDATASETNUMMBEROFECUDATACONTNUM_SIZE] = /* PRQA S 1504 */{   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/*! \misra PRQA 1504 "The variable used in other component too" */VAR(uint8, IDP_VAR) DID_F1A1_VWDataSetVersionNumber[DID_F1A1_VWDATASETVERSIONNUMBER_SIZE] = /* PRQA S 1504 */{   DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};/*@@ SYMBOL = Idp_ExpectedModelType@@ A2L_TYPE = MEASURE@@ DATA_TYPE = UBYTE@@ DESCRIPTION = "Stored value of Expected_model_type DID. The 0-3 bits define the model type"@@ GROUP = IDP@@ END*//*! \misra PRQA 1504 "The variable used in other component too" */VAR(uint8, IDP_VAR) Idp_ExpectedModelType = 0x00U; /* PRQA S 1504 *//*@@ SYMBOL = KnockOutTestBit@@ A2L_TYPE = MEASURE@@ DATA_TYPE = UBYTE@@ DESCRIPTION = "Test bit for KnockOut from UDS service"@@ GROUP = IDP@@ END*/STATIC VAR(uint8, IDP_VAR) KnockOutTestBit = 0x00U;/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_STOP_SEC_BSW_VAR_INIT_LOCAL_UNSPECIFIED  /* PRQA S 4800 */#include "Idp_MemMap.h"/*================== [prototype of local functions] =========================*//*! \misra PRQA 4800 "This define automatically generated" */#define Idp_START_SEC_BSW_CODE_LOCAL  /* PRQA S 4800 */#include "Idp_MemMap.h"/* Declaration of static function Idp_ValidateAdminTable() */STATIC FUNC(boolean, RTE_CODE) Idp_ValidateAdminTable (P2CONST(t_AdminTable, AUTOMATIC, RTE_APPL_DATA) pAdminTable);/* Declaration of static function Idp_ReadDIDFromInfoTable() *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */STATIC FUNC(boolean, RTE_CODE) Idp_ReadDIDFromInfoTable      (P2CONST(t_AdminTable, AUTOMATIC, RTE_APPL_DATA) pAdminTable, uint16 DID_id,      P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) DID_data, uint16 DID_size); /* PRQA S 3432 *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */LOCAL_INLINE FUNC(boolean, RTE_CODE) Idp_ReadOut_the_founded_DID      (uint8 i, P2CONST(t_GenInfoTbl, AUTOMATIC, RTE_APPL_DATA) pInfoTable,      P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) DID_data, uint16 DID_size); /* PRQA S 3432 */LOCAL_INLINE FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_CheckFormat(const uint8 msg[], uint16 DataLength);/*================== [definition of local functions] ========================*//*****************************************************************************//*! * \fn      FUNC(boolean, RTE_CODE) Idp_ValidateAdminTable (const t_AdminTable* pAdminTable) * \brief   This function checks that the AdminTable is pointing to valid memory space. * \param   [in] pAdminTable: AdminTable start address * \param   [out] pAdminTable: AdminTable start address * \param   [out] retStatus: The status of the function's execution. * \return  boolean   Return the status of AdminTable * \retval  TRUE      AdminTable is valid * \retval  FALSE     AdminTable is invalid *//*****************************************************************************/STATIC FUNC(boolean, RTE_CODE) Idp_ValidateAdminTable (P2CONST(t_AdminTable, AUTOMATIC, RTE_APPL_DATA) pAdminTable){   boolean retStatus = FALSE;   uint32 AdminTable_size = sizeof(t_AdminTable);   /*! \misra PRQA 0310 "chkprg_is_valid_rom_addr" function checks that after the cast   operator it is pointing to valid memory space." */   if (TRUE == chkprg_is_valid_rom_addr((const uint8*)pAdminTable)) /* PRQA S 0310 */   {      /* Check if admin-Table is valid */      if ((STARTPATTERN == (pAdminTable->BlkId & ADMIN_TABLE_VALIDITY_BITMASK)) &&               (pAdminTable->LenAdmnBlk == AdminTable_size)    )      {         /* Check if valid marker is set and block is not invalidated */         /* Function "chkprg_is_marker_set" has no side effect */         if ((TRUE == chkprg_is_marker_set                  (pAdminTable->AddrValidMrkr, pAdminTable->LenValidMrkr, ADMIN_TABLE_PATTERN_MASK)) &&            /*! \misra PRQA 3415 "The logical operand is right" */            (FALSE == chkprg_is_marker_set /* PRQA S 3415 */              (pAdminTable->AddrInvalidMrkr, pAdminTable->LenInvalidMrkr, ADMIN_TABLE_PATTERN_MASK)))         {            /* Check that info table is a valid pointer in PFlash */            /*! \misra PRQA 0310 "chkprg_is_valid_rom_addr" function checks that after the cast            operator it is pointing to valid memory space." */            if (TRUE == chkprg_is_valid_rom_addr((const uint8*)pAdminTable->AddrInfoTbl)) /* PRQA S 0310 */            {               retStatus = TRUE;            }         }      }   }   return retStatus;}/*****************************************************************************//*! * \fn      STATIC FUNC(boolean, RTE_CODE) Idp_ReadDIDFromInfoTable                  (P2CONST(t_AdminTable, AUTOMATIC, RTE_APPL_DATA) pAdminTable, uint16 DID_id,                  P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) DID_data, uint16 DID_size) * \brief   This  function copies DID data from the AdminTable. * \param   [in]  pAdminTable: AdminTable start address * \param   [in]  DID_id: DID which want to read from the Info Table * \param   [out] DID_data: DID data buffer * \param   [in]  DID_size:  DID data size * \retval  TRUE  Copy of the wanted DID is successfull * \retval  FALSE Copy of the wanted DID is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */STATIC FUNC(boolean, RTE_CODE) Idp_ReadDIDFromInfoTable      (P2CONST(t_AdminTable, AUTOMATIC, RTE_APPL_DATA) pAdminTable, uint16 DID_id,      P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) DID_data, uint16 DID_size) /* PRQA S 3432 */{   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   boolean retStatus = FALSE; /* PRQA S 2981 */   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   const t_GenInfoTbl* pInfoTable = NULL_PTR; /* PRQA S 2981 */   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 InfoTable_size = 0U; /* PRQA S 2981 */   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 i = 0U; /* PRQA S 2981 */   /* QAC: After the cast and array subscript operator the "chkprg_is_valid_rom_addr" function */   /* checks that it is pointing to valid memory space.                                        */   /* Check that the start address is pointing to valid memory space. */   retStatus = Idp_ValidateAdminTable(pAdminTable);   if(TRUE == retStatus)   {      pInfoTable = pAdminTable->AddrInfoTbl;      InfoTable_size = pInfoTable->NumGenPurpInfoStrcts;      retStatus = FALSE;      /* Search the DID witch want to read from the Info Table */      for (i = 0U; i < InfoTable_size; i++)      {         /*! \misra PRQA 0491 "This array subscript operator is useable here" */         if (pInfoTable->GenPurpInfoStrct[i].Id == DID_id) /* PRQA S 0491 */         {            retStatus = Idp_ReadOut_the_founded_DID(i,pInfoTable, DID_data, DID_size);         }      }   }   return retStatus;}/*****************************************************************************//*! * \fn      LOCAL_INLINE FUNC(boolean, RTE_CODE) Idp_ReadOut_the_founded_DID                  (uint8 i, P2CONST(t_GenInfoTbl, AUTOMATIC, RTE_APPL_DATA) pInfoTable,                  P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) DID_data, uint16 DID_size) * \brief   This function reads the founded DID from the AdminTable. * \param   [in]  i: Index variable. * \param   [in]  pInfoTable: AdminTable start address * \param   [in]  DID_data: DID data buffer * \param   [in]  DID_size:  DID data size * \param   [out] pInfoTable: AdminTable start address * \param   [out] DID_data: DID data buffer * \param   [out] retStatus: The status of the function's execution * \retval  TRUE  Read of the wanted DID is successfull * \retval  FALSE Read of the wanted DID is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */LOCAL_INLINE FUNC(boolean, RTE_CODE) Idp_ReadOut_the_founded_DID      (uint8 i, P2CONST(t_GenInfoTbl, AUTOMATIC, RTE_APPL_DATA) pInfoTable,      P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) DID_data, uint16 DID_size) /* PRQA S 3432 */{   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   const uint8* addr = NULL_PTR; /* PRQA S 2981 */   boolean retStatus = FALSE;   /*! \misra PRQA 0306,0491 "This array subscript operator is useable here" */   addr = (const uint8*)pInfoTable->GenPurpInfoStrct[i].Addr; /* PRQA S 0306,0491 */   /* Check that the start address is a valid pointer in PFlash */   if (TRUE == chkprg_is_valid_rom_addr(addr))   {      /* copy data into the result buffer */      /*! \misra PRQA 0491 "This cast is useable here" */      if(pInfoTable->GenPurpInfoStrct[i].Len == DID_size) /* PRQA S 0491 */      {         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(DID_data, addr, (uint32)DID_size); /* PRQA S 0315 */         retStatus = TRUE;      }   }   return retStatus;}/*****************************************************************************//*! * \fn      LOCAL_INLINE FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_CheckFormat(const uint8 msg[], uint16 DataLength) * \brief   This function checks the F1A0 DID data format *          [HIS] STVOC2 'Language scope 'VOCF' per function' is exceeded *          It is necessary to maintain a reasonable SW design, ensure the good behavior and optimal performace. * \param   [in] msg: Array to hold teh DID value * \param   [in] DataLength: Length of the data * \return  Success of operation. * \retval  RTE_E_OK - Format is OK * \retval  E_NOT_OK - Format is NOK *//*****************************************************************************/LOCAL_INLINE FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_CheckFormat(const uint8 msg[], uint16 DataLength){   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 i = 0U; /* PRQA S 2981 */   Std_ReturnType retStatus = RTE_E_OK;   /*! \misra PRQA 0771 "Improve the running speed" */   for (i = 0U; i < DataLength; i++) /*PRQA S 0771*/   {      if ( (i < F1A0_MIDDLE_NUMBER_TH) &&         ( (F1A0_PROHIBITED_CHAR == msg[i]) ||         (F1A0_RANGE_LOW_TH > msg[i]) ||         (F1A0_FRONT_SUFFIX_NM_RANGE_HIGH_TH < msg[i]) ) )  /* Front number range check */      {         retStatus=E_NOT_OK;         break;      }      else if ( ( (i >= F1A0_MIDDLE_NUMBER_TH) &&              (i < F1A0_PART_NUMBER_SUFFIX_TH) ) &&              ((F1A0_RANGE_LOW_TH > msg[i]) ||              (F1A0_MIDDLE_NM_RANGE_HIGH_TH < msg[i]) ) ) /* Middle and end group range check */      {         retStatus=E_NOT_OK;         break;      }      else if ( (i >= F1A0_PART_NUMBER_SUFFIX_TH) &&              (F1A0_SPACE_CHAR != msg[i]) &&              ((F1A0_SUFFIX_RANGE_LOW_TH > msg[i]) ||              (F1A0_FRONT_SUFFIX_NM_RANGE_HIGH_TH < msg[i]) ) ) /* Part number suffix range check */      {         retStatus=E_NOT_OK;         break;      }      else      {          ; /* Supress QAC warning */      }   }   return retStatus;}/*================== [definition of global functions] =======================*//* PRQA S 1503 EOF */ /* These functions are in use, called by the RTE. *//*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F187_VWSparePartNumber_ReadData *                                     (P2VAR(Dcm_DataF187_VWSparePartNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F187 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F187_SparePartNumber[0U]), DID_F187_VWSPAREPARTNUMBER_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F189_VWApplicationSoftwareVersionNumber_ReadData *                    (P2VAR(Dcm_DataF189_VWApplicationSoftwareVersionNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F189 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F189_VWApplicationSoftwareVersionNumber[0U]), /* PRQA S 0315 */                DID_F189_VWSOFTWAREVERSIONNUMBER_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F18C_ECUSerialNumber_ReadData *                                       (P2VAR(Dcm_DataF18C_ECUSerialNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F18C DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParamOem.F18C_EcuSerNum[0U]), DID_F18C_ECUSERIALNUMBER_SIZE); /* PRQA S 0315 */      DidUtil_ASCIIfyNULLs(Data, DID_F18C_ECUSERIALNUMBER_SIZE);    }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F191_ECUHardwareNumber_ReadData *                                     (P2VAR(Dcm_DataF191_ECUHardwareNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F191 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParamOem.F191_EcuHwNumber[0U]), /* PRQA S 0315 */                DID_F191_VWECUHARDWARENUMBER_SIZE);      DidUtil_ASCIIfyNULLs(Data, DID_F191_VWECUHARDWARENUMBER_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F192_SystemSupplierECUHardwareNumber_ReadData *                       (P2VAR(Dcm_DataF192_SystemSupplierECUHardwareNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F192 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParam.A5E_CU[0U]), DID_F192_SYS_SUPP_ECU_HW_NUM_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F194_SystemSupplierECUSoftwareNumber_ReadData *                       (P2VAR(Dcm_DataF194_SystemSupplierECUSoftwareNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F194 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, SysSuppEcuSwNum_ptr, DID_F194_SYS_SUPP_ECU_SW_NUM_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType,RTE_CODE) Idp_F195_SystemSupplierECUSoftwareVersionNumber_ReadData *                (P2VAR(Dcm_DataF195_SystemSupplierECUSoftwareVersionNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F194 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, SysSuppEcuSwVerNum_ptr, DID_F195_SYS_SUPP_ECU_SW_VER_NUM_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F19E_AsamOdxFileIdentifier_ReadDataLength *                                                                  (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) DidLength) * \brief   This function set the F19E DID length. * \param   [in] DidLength: Variable what will be store the DID length. * \param   [out] DidLength: Variable what will be store the DID length. * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//*! \misra PRQA 3432  "This is generated by Tresos this way. Macro expansion does not result in expression where operator precedence could cause an issue, so the warning can be safely suppressed. Resolving by adding parentheses is not possible because it would result in compile error, and the SW cannot be built." */FUNC(Std_ReturnType, RTE_CODE) Idp_F19E_AsamOdxFileIdentifier_ReadDataLength                                       (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) DidLength) /*PRQA S 3432*/{   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 cntr = 0U; /* PRQA S 2981 */   boolean null_flag = FALSE;   uint8 DID_length = DID_F19E_ASAMODXFILEIDENTIFIER_MAX_SIZE;   if(NULL_PTR != DidLength)   {      /* Search the first NULL byte */      for(cntr = 0U; cntr < DID_F19E_ASAMODXFILEIDENTIFIER_MAX_SIZE; cntr++)      {         if(FALSE == null_flag)         {            /* Save the first NULL byte position. */            if(0U == F19E_AsamOdxFileIdentifier[cntr])            {               DID_length = cntr + 1U;               null_flag = TRUE;            }         }      }      /* If the NULL byte is not exist, than the size of the DID is 25 byte (init value) due to Q-LAH_80125_T2-7: */      /* For the case that this DataIdentifier is calibrated with 25 bytes, it must not be terminated by 0x00 */      *DidLength = (uint16)DID_length;   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F19E_AsamOdxFileIdentifier_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F19E DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 cntr = 0U; /* PRQA S 2981 */   boolean null_flag = FALSE;   uint8 DID_length = DID_F19E_ASAMODXFILEIDENTIFIER_MAX_SIZE;   if(NULL_PTR != Data)   {      /* Search the first NULL byte */      for(cntr = 0U; cntr < DID_F19E_ASAMODXFILEIDENTIFIER_MAX_SIZE; cntr++)      {         if(FALSE == null_flag)         {            /* Save the first NULL byte position. */            if(0U == F19E_AsamOdxFileIdentifier[cntr])            {               DID_length = cntr + 1U;               null_flag = TRUE;            }         }      }      /* If the NULL byte is not exist, than the size of the DID is 25 byte (init value) due to Q-LAH_80125_T2-7: */      /* For the case that this DataIdentifier is calibrated with 25 bytes, it must not be terminated by 0x00 */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, F19E_AsamOdxFileIdentifier, (uint32)DID_length); /* PRQA S 0315 */      }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A2_AsamOdxFileVersion_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1A2 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F1A2_AsamOdxFileVersion[0U]), DID_F1A2_ASAMODXFILEVERSION_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A3_VWECUHardwareVersionNumber_ReadData *                            (P2VAR(Dcm_DataF1A3_VWECUHardwareVersionNumber_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1A3 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   Std_ReturnType retStatus = RTE_E_OK; /* PRQA S 2981 */   HwLifeCycStType hwLifeCycSt;   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParamOem.F1A3_EcuHwVersion[0U]), /* PRQA S 0315 */                DID_F1A3_VWECUHARDWAREVERSIONNUMBER_SIZE);      DidUtil_ASCIIfyNULLs(Data, DID_F1A3_VWECUHARDWAREVERSIONNUMBER_SIZE);      /* Overwrite the Life cyle byte (first byte) */      retStatus = Rte_Read_HwLifeCycSt_LifeCycSt(&hwLifeCycSt);      if( (RTE_E_OK == retStatus) && (LIFECYCLE_SERIES == hwLifeCycSt) )      {         /* Set the first byte to "series" */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemSet(Data, (uint8)'H', 1U); /* PRQA S 0315 */      }      else if( (RTE_E_OK == retStatus) &&               (LIFECYCLE_SAMPLE == hwLifeCycSt) &&               ( ASCII_Y_HEX != EcuProdDataParamOem.F1A3_EcuHwVersion[0U]) )      {         /* Set the first byte to "sample" */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemSet(Data, (uint8)'X', 1U); /* PRQA S 0315 */      }      else      {         /* Do nothing, the production data information will be used. */      }   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1AD_EngineCodeLetters_ReadData *                      (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1AD DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//*! \misra PRQA 3432  "This is generated by Tresos this way. Macro expansion does not result in expression whereoperator precedence could cause an issue, so the warning can be safely suppressed. Resolving by adding parenthesesis not possible because it would result in compile error, and the SW cannot be built." */FUNC(Std_ReturnType, RTE_CODE) Idp_F1AD_EngineCodeLetters_ReadData                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /*PRQA S 3432*/{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F1AD_EngineCodeLetters[0U]), DID_F1AD_ENGINECODELETTERS_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1B4_Technical_specifications_version_ReadData *                      (P2VAR(Dcm_DataF1B4_Technical_specifications_version_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1B4 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F1B4_TechnicalSpecificationVersion), DID_F1B4_TECHSPECVERSION_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) F1B8_VW_system_firmware_versions_ReadDataLength *                                                                  (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) DidLength) * \brief   This function set the F1B8 DID length. * \param   [in] DidLength: Variable what will be store the DID length. * \param   [out] DidLength: Variable what will be store the DID length. * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" *//*! \misra PRQA 3206 "The function prototype is generated by Tresos, which includes also not used arguments." */FUNC(Std_ReturnType, RTE_CODE) F1B8_VW_system_firmware_versions_ReadDataLength      (Dcm_OpStatusType OpStatus, P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) DidLength) /* PRQA S 3432 */ /* PRQA S 3206 */{   uint8 pData[FW_SBL_NUMBER_OF_VERSION_BYTES];   Fw_ReadFirmwareVersions();   if (Fw_GetSiemensBootloaderVersion(pData) == TRUE)   {      *DidLength = DID_F1B8_FIRMWARE_VERSION_SIZE_FULL;   }   else   {      *DidLength = DID_F1B8_FIRMWARE_VERSION_SIZE_WITHOUT_SB;   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1B8_VW_system_firmware_versions_ReadData *                           (P2VAR(Dcm_DataF1B8_VW_system_firmware_versions_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1B8 DID readability via UDS. *          [HIS] STVOC2 'Language scope 'VOCF' per function' is exceeded *          It is necessary to maintain a reasonable SW design, ensure the good behavior and optimal performace. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1B8_VW_system_firmware_versions_ReadData                             (Dcm_OpStatusType OpStatus, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   uint8* pData = (uint8*)Data;   uint8 noFwModules = 0U;   Std_ReturnType retVal = E_OK;   (void)OpStatus; /* suppress unused argument warning */   if(NULL_PTR != Data)   {      if(FALSE == SftyC2cData.PuVersFlag)      {         retVal = DCM_E_PENDING;      }      else      {         /* Read Firmware versions of SiemensBoot (if present), BootManager, and HSM */         Fw_ReadFirmwareVersions();         /* First byte is the number of firmware modules */         /*! \misra PRQA 0489 "This pointer arithmetic is permitted and needed" */         pData++;  /* PRQA S 0489 */         if (Fw_GetSiemensBootloaderVersion(pData) == TRUE)         {            /* Siemens bootloader is optional module,set output bytes only if this is available */            /*! \misra PRQA 0488 "This pointer arithmetic is permitted and needed" */            pData += FW_SBL_NUMBER_OF_VERSION_BYTES;  /* PRQA S 0488 */            /*! \misra PRQA 0488 "This operation is needed." */            noFwModules++;  /* PRQA S 2984 */         }         /* Always write BM version bytes, default value is used if not available */         (void)Fw_GetBootManagerVersion(pData);         /*! \misra PRQA 0488 "This pointer arithmetic is permitted and needed" */         pData += FW_BM_NUMBER_OF_VERSION_BYTES;  /* PRQA S 0488 */         noFwModules++;         /* Always write HSM version bytes, default value is used if not available */         (void)Fw_GetHsmVersion(pData);         /*! \misra PRQA 0488 "This pointer arithmetic is permitted and needed" */         pData += FW_HSM_NUMBER_OF_VERSION_BYTES;  /* PRQA S 0488 */         noFwModules++;         /* format ADIS BM version */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[0U] = ASCII_A; /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[1U] = ASCII_M; /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[2U] = ASCII_0 + (uint8)((SftyC2cData.PuBmVers >> 4U) & 0x0FU ); /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[3U] = ASCII_0 + (uint8)(SftyC2cData.PuBmVers & 0x0FU); /* PRQA S 0491 */         /*! \misra PRQA 0488 "This pointer arithmetic is permitted and needed" */         pData += FW_PU_BM_NUMBER_OF_VERSION_BYTES;  /* PRQA S 0488 */         noFwModules++;         /* format ADIS BL version */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[0U] = ASCII_A; /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[1U] = ASCII_L; /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[2U] = ASCII_0 + (uint8)((SftyC2cData.PuBlVers >> 4U) & 0x0FU ); /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         pData[3U] = ASCII_0 + (uint8)(SftyC2cData.PuBlVers & 0x0FU); /* PRQA S 0491 */         /*! \misra PRQA 0491 "Array subscripting on pointer is necessary due to the given AutoSAR interface." */         noFwModules++;         /* Now we know the number of firmware modules, update first byte */         *Data = noFwModules;      }   }   return retVal;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1DF_ECUProgrammingInformation_ReadData *                             (P2VAR(Dcm_DataF1DF_ECUProgrammingInformation_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1DF DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   const uint8 WRITE_DID_F1DF_ECUProgrammingInformation = DID_F1DF_ECUPROGRAMMINGINFORMATION;   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &WRITE_DID_F1DF_ECUProgrammingInformation, DID_F1DF_ECUPROGINFO_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F197_VWSystemNameOrEngineType_ReadData *                              (P2VAR(Dcm_DataF197_VWSystemNameOrEngineType_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F197 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F197_VWSystemNameOrEngine[0U]), DID_F197_VWSYSTEMNAME_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x0407_VWLogicalSoftwareBlockCounterOfProgrammingAttempts_ReadData *          (P2VAR(Dcm_Datax0407_VWLogicalSoftwareBlockCounterOfProgrammingAttempts_ArrayType, *          AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 0407 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   uint8 blockindex;   if(NULL_PTR != Data)   {      /* DownGradeProtection incl. */      for (blockindex = 0U; blockindex < (NUMBER_OF_SOFTWARE_BLOCKS-1U); blockindex++ )      {          VWLogicalSoftwareBlockCounterOfProgrammingAttempts[blockindex] =                                                        VAG_BL_BlockNvData_store.blockData[blockindex+1U].ProgAttempts;          /* Byte order have to be swapped for the diagnostic response because           of the intel/motorola byte order conversion. */          /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,          source and destination are the same type" */          Util_SwapBytes(&(VWLogicalSoftwareBlockCounterOfProgrammingAttempts[blockindex]),2U); /* PRQA S 0315 */      }      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(VWLogicalSoftwareBlockCounterOfProgrammingAttempts[0U]), /* PRQA S 0315 */                DID_0407_VWLOGICALSWBLCNTOFPRGATT_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x040F_VWLogicalSoftwareBlockLockValue_ReadData *                      (P2VAR(Dcm_Datax040F_VWLogicalSoftwareBlockLockValue_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 040F DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   uint8 blockindex;   uint8 empty_local = 0U;   if(NULL_PTR != Data)   {      /* DownGradeProtection incl. */      for (blockindex = 0U; blockindex < (NUMBER_OF_SOFTWARE_BLOCKS-1U); blockindex++ )      {         DID_040F_VWLogicalSoftwareBlockLockValue[blockindex] =                                                     VAG_BL_BlockNvData_store.blockData[blockindex+1U].MaxProgAttempts;         /* Check if NvM block is empty */         if (0x0000U == DID_040F_VWLogicalSoftwareBlockLockValue[blockindex])         {            empty_local++;         }         else         {            /* Byte order have to be swapped for the diagnostic response because            of the intel/motorola byte order conversion. */            /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,            source and destination are the same type" */            Util_SwapBytes(&(DID_040F_VWLogicalSoftwareBlockLockValue[blockindex]),2U); /* PRQA S 0315 */         }      }      /* copy data into the result buffer */      if (empty_local == (NUMBER_OF_SOFTWARE_BLOCKS-1U))      {         /* Common NvM block is empty, use default data */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(Data, &(DID_040F_VWLogicalSoftwareBlockLockValue_Default[0U]), /* PRQA S 0315 */                           DID_040F_VWLOGICALSWBLLOCKVALUE_SIZE*(NUMBER_OF_SOFTWARE_BLOCKS-1U));      }      else      {         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(Data, &(DID_040F_VWLogicalSoftwareBlockLockValue[0U]), /* PRQA S 0315 */                                DID_040F_VWLOGICALSWBLLOCKVALUE_SIZE*(NUMBER_OF_SOFTWARE_BLOCKS-1U));      }   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x0410_BootloaderTPBlocksize_ReadData *                                (P2VAR(Dcm_Datax0410_BootloaderTPBlocksize_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 0410 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(DcmExtCblApplShareData.DID_0410_BootloaderTPBlocksize), /* PRQA S 0315 */                                DID_0410_BLFTPBLOCK_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks_ReadData *          (P2VAR(Dcm_DataF15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks_ArrayType, *          AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F15B DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   uint8 blockindex;   if(NULL_PTR != Data)   {      /* DownGradeProtection incl. */      for (blockindex = 0U; blockindex < (NUMBER_OF_SOFTWARE_BLOCKS-1U); blockindex++ )      {         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy( /* PRQA S 0315 */           &(F15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks[blockindex].BlockPgmDate[0U]),           &(VAG_BL_BlockNvData_store.blockData[blockindex+1U].DID_F15A_BlockPgmDate[0U]),           DID_F15A_BLOCKPGMDATE_SIZE);          /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy( /* PRQA S 0315 */           &(F15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks[blockindex].BlockTesterSerial[0U]),           &(VAG_BL_BlockNvData_store.blockData[blockindex+1U].DID_F15A_BlockTesterSerial[0U]),            DID_F15A_BLOCKTESTERSERIAL_SIZE);         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy( /* PRQA S 0315 */           &(F15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks[blockindex].ProgrammingState),           &(VAG_BL_BlockNvData_store.blockData[blockindex+1U].BlockState),            1U);      }      for (blockindex = 0U; blockindex < (NUMBER_OF_SOFTWARE_BLOCKS-1U); blockindex++ )      {         /* copy data into the result buffer */         /* The array operand is needed for the correct data handling */         /*! \misra PRQA 0492 "The array operand is needed for the correct data handling" */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy( /* PRQA S 0492 */ /* PRQA S 0315 */           &(Data[blockindex*DID_F15B_FINGERPRINTANDPRGDATEOFLOGSWBL_SIZE]),           &(F15B_FingerprintAndProgrammingDateOfLogicalSoftwareBlocks[blockindex]),           DID_F15B_FINGERPRINTANDPRGDATEOFLOGSWBL_SIZE);      }   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F18A_SystemSupplierIdentifier_ReadData *                              (P2VAR(Dcm_DataF18A_SystemSupplierIdentifier_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F18A DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(F18A_SystemSupplierIdentifierNumber[0U]), DID_F18A_VWSYSSUPIDNUM_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_VWDataSetNumberOrECUDataContainerNumber_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1A0 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_VWDataSetNumberOrECUDataContainerNumber_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{  if(NULL_PTR != Data)  {     /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,     source and destination are the same type" */     TS_MemCpy(Data, &(DID_F1A0_VwDataSetVersionNumber[0U]), /* PRQA S 0315 */               DID_F1A0_VWDATASETNUMMBEROFECUDATACONTNUM_SIZE);  }  return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_VWDataSetNumberOrECUDataContainerNumber_WriteData            (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, uint16 DataLength,            P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the F1A0 DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_VWDataSetNumberOrECUDataContainerNumber_WriteData                          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, uint16 DataLength,                          P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{  /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */  Std_ReturnType retStatus = RTE_E_OK; /* PRQA S 2981 */  uint8 msg[F1A0_VWDATASETNUMBERORECUDATACONTAINERNUMBER_SIZE];  uint16 localDataLength = DataLength;  if(NULL_PTR != Data)  {     /* Process the incoming Data, because only specific range numbers is acceptable. */     /*! \misra PRQA 4471 "Needed for data analyzing" */     /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,     source and destination are the same type" */     TS_MemCpy(&(msg[0U]),Data,localDataLength); /*PRQA S 4471*/ /* PRQA S 0315 */     retStatus = Idp_F1A0_CheckFormat(msg,localDataLength);     if (RTE_E_OK == retStatus) /* If the ranges are correct */     {        while(F1A0_VWDATASETNUMBERORECUDATACONTAINERNUMBER_SIZE > localDataLength) /* DataIdentifier filling in */        {           msg[localDataLength] = F1A0_SPACE_CHAR;           localDataLength++;        }        /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,        source and destination are the same type" */        TS_MemCpy( /* PRQA S 0315 */           &(DID_F1A0_VwDataSetVersionNumber[0U]), &(msg[0U]), DID_F1A0_VWDATASETNUMMBEROFECUDATACONTNUM_SIZE);        (void) Rte_Call_Idp_PS_NvM_BLOCK_VW_DATA_SET_NUMBER_SetRamBlockStatus (TRUE);        (void) Rte_Call_Idp_PS_NvM_BLOCK_VW_DATA_SET_NUMBER_WriteBlock (NULL_PTR);     }     else     {        *ErrorCode=DCM_E_REQUESTOUTOFRANGE;     }  }  else  {     retStatus = E_NOT_OK;  }  return retStatus;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_VWDataSetNumberOrECUDataContainerNumber_ReadDataLength *                                                                  (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) DidLength) * \brief   This function handles the F1A0 DID length readability via UDS. * \param   [in] Data: Variable what will be store the needed DID length * \param   [out] Data: Variable what will be store the needed DID length * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1A0_VWDataSetNumberOrECUDataContainerNumber_ReadDataLength                                (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) DidLength) /* PRQA S 3432 */{   if(NULL_PTR != DidLength)   {      *DidLength = DID_F1A0_VWDATASETNUMMBEROFECUDATACONTNUM_SIZE;   }  return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1AA_VWWorkshopSystemName_ReadData *                                  (P2VAR(Dcm_DataF1AA_VWWorkshopSystemName_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1AA DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   uint8 VWWorkshopSystemName[DID_F1AA_VWWORKSHOPSYSTEMNAME_SIZE] = {0x4AU, 0x38U, 0x34U, 0x31U, 0x20U};                                          /* This is an ID added in hex for ascii according to req: Q-LAH_80125_T2-11*/   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(VWWorkshopSystemName[0U]), DID_F1AA_VWWORKSHOPSYSTEMNAME_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1AB_VWLogicalSoftwareBlockVersion_ReadData *                        (P2VAR(Dcm_DataF1AB_VW_LogicalSoftwareBlockVersion_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1AB DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   uint8 blockindex;   if(NULL_PTR != Data)   {      /* DownGradeProtection incl. */      for (blockindex = 0U; blockindex < (NUMBER_OF_SOFTWARE_BLOCKS-1U); blockindex++ )      {         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(&(VWLogicalSoftwareBlockVersion[blockindex*DID_F1AB_LOGICALBLOCKVERSION_SIZE]), /* PRQA S 0315 */                  &(VAG_BL_BlockNvData_store.blockData[blockindex+1U].DID_F1AB_LogicalBlockVersion[0U]),                  DID_F1AB_LOGICALBLOCKVERSION_SIZE);      }      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(VWLogicalSoftwareBlockVersion[0U]), /* PRQA S 0315 */               (DID_F1AB_LOGICALBLOCKVERSION_SIZE*(NUMBER_OF_SOFTWARE_BLOCKS-1U)));   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1AF_AUTOSAR_standard_application_software_identification_ReadData *          (P2VAR(Dcm_DataF1AF_AUTOSAR_standard_application_software_identification_ArrayType, *          AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1AF DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   Std_VersionInfoType SecDiagSwc = {0U, 0U, 0U, 0U, 0U};   uint16 moduleID_temp;   if(NULL_PTR != Data)   {      SecDiagSwc.vendorID = DID_F1AF_SFDA_CFG_VENDOR_ID;      SecDiagSwc.moduleID = DID_F1AF_SFDA_CFG_MODULE_ID;      SecDiagSwc.sw_major_version = DID_F1AF_SFDA_CFG_SW_MAJOR_VERSION;      SecDiagSwc.sw_minor_version = DID_F1AF_SFDA_CFG_SW_MINOR_VERSION;      SecDiagSwc.sw_patch_version = DID_F1AF_SFDA_CFG_SW_PATCH_VERSION;      /* convert little endian to big endian */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      Util_SwapBytes(&SecDiagSwc.moduleID, sizeof(SecDiagSwc.moduleID)); /* PRQA S 0315 */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      Util_SwapBytes(&SecDiagSwc.vendorID, sizeof(SecDiagSwc.vendorID)); /* PRQA S 0315 */      /* Swap the moduleID with the vendorID, because the order of structure members is different from the */      /* DID format: SSW-Modul ID (2 Byte) + Vendor-ID (2 Byte) + SSW-Version (3 Byte).                    */      moduleID_temp = SecDiagSwc.moduleID;      SecDiagSwc.moduleID = SecDiagSwc.vendorID;      SecDiagSwc.vendorID = moduleID_temp;      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &SecDiagSwc, DID_F1AF_AUTOSARSTDAPPSWID_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1B6_System_identification_ReadData *                                 (P2VAR(Dcm_DataF1B6_System_identification_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1B6 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(DID_F1B6_Systemidentification[0U]), DID_F1B6_SYSTEMIDENTIFICATION_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      Std_ReturnType Idp_x0102_BasicSettingsStatus_ReadData *                                 (P2VAR(Dcm_DataF1B6_System_identification_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 0102 DID readability via UDS. * \param   [in] None * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(DID_0102_BasicSettingsStatus), DID_0102_BASICSETTINGSTATUS_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x0261_OBD_Driving_Cycle_set_once_ReadData *                           (P2VAR(Dcm_Datax0261_OBD_Driving_Cycle_set_once_ArrayType, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 0261 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data */{   ObdNonvolStructType Idp_OBDNonvolatiles = {0U, 0U, 0U, 0U, 0U};   if(NULL_PTR != Data)   {      (void)Rte_Read_OBD_DCY_InitiallySet_ObdNonvolStructType(&Idp_OBDNonvolatiles);      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           Data, &(Idp_OBDNonvolatiles.OBD_DCY_Q_InitiallySet), DID_0261_DRIVINGCYCLESETONCE_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x02CA_Knockout_counter_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 02CA DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x02CA_Knockout_counter_ReadData                              (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   uint8 KnockOutCtrData[DID_02CA_KNOCKOUTCOUNTER_SIZE];   if(NULL_PTR != Data)   {      (void)Rte_Call_Internal_KnockOut_KnockOutCtrINT_IF(&KnockOutCtrData[BUSKNOCKOUT_BYTE],                                                         &KnockOutCtrData[ECUKNOCKOUT_BYTE]);      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data,&(KnockOutCtrData),DID_02CA_KNOCKOUTCOUNTER_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x02CA_Knockout_counter_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, P2VAR(Dcm_NegativeResponseCodeType, *          AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 02CA DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x02CA_Knockout_counter_WriteData (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,                             P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{   Std_ReturnType statusKnockOutCtrWrite = RTE_E_OK;   uint8 CounterData[DID_02CA_KNOCKOUTCOUNTER_SIZE];   boolean  CounterDataChanged = FALSE;   if (NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(&(CounterData),Data,DID_02CA_KNOCKOUTCOUNTER_SIZE); /* PRQA S 0315 */      if ((ECUKO_CTR_OVERFLOW >= CounterData[ECUKNOCKOUT_BYTE])       && (BUSKO_CTR_OVERFLOW >= CounterData[BUSKNOCKOUT_BYTE]))      {         KnockOutParameterCtr.ECUKnockout_Ctr = CounterData[ECUKNOCKOUT_BYTE];         KnockOutParameterCtr.BusKnockout_Ctr = CounterData[BUSKNOCKOUT_BYTE];         CounterDataChanged = TRUE;      }      else      {         *ErrorCode = DCM_E_REQUESTOUTOFRANGE;         statusKnockOutCtrWrite = E_NOT_OK;      }   }   else   {      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;      statusKnockOutCtrWrite = E_NOT_OK;   }   if (TRUE == CounterDataChanged)   {      (void)Rte_Call_PS_NvM_BLOCK_KNOCK_OUT_PARAMETER_CTR_SetRamBlockStatus(TRUE);      (void)Rte_Call_PS_NvM_BLOCK_KNOCK_OUT_PARAMETER_CTR_WriteBlock(NULL_PTR);   }   return statusKnockOutCtrWrite;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x02CB_Knockout_timer_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 02CB DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x02CB_Knockout_timer_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   uint8 KnockOutTmrData[DID_02CB_KNOCKOUTTIMER_SIZE];   if(NULL_PTR != Data)   {      KnockOutTmrData[ECUKNOCKOUT_BYTE] = KnockOutParameterTmr.ECUKnockout_Tmr;      KnockOutTmrData[BUSKNOCKOUT_BYTE] = KnockOutParameterTmr.BusKnockout_Tmr;      /* NVEM shall not be used according to [KO_911] */      KnockOutTmrData[NVEMKNOCKOUT_BYTE] = DID_PARAM_NOT_IMPLEMENTED;      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, KnockOutTmrData, DID_02CB_KNOCKOUTTIMER_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x02CB_Knockout_timer_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, P2VAR(Dcm_NegativeResponseCodeType, *          AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 02CB DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x02CB_Knockout_timer_WriteData (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,                             P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{   Std_ReturnType statusKnockOutTmrWrite = RTE_E_OK;   uint8 TimerData[DID_02CB_KNOCKOUTTIMER_SIZE];   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 DataTmrEcu = 0x00U; /* PRQA S 2981 */   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */      uint8 DataTmrBus = 0x00U; /* PRQA S 2981 */   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */      uint8 DataTmrNVEM = 0x00U; /* PRQA S 2981 */   if (NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(TimerData, Data, DID_02CB_KNOCKOUTTIMER_SIZE); /* PRQA S 0315 */      DataTmrEcu = (uint8)(TimerData[ECUKNOCKOUT_BYTE] & ECU_KNOCKOUT_TMR_BITMASK);      DataTmrBus = (uint8)(TimerData[BUSKNOCKOUT_BYTE] & BUS_KNOCKOUT_TMR_BITMASK);      DataTmrNVEM = (uint8)(TimerData[NVEMKNOCKOUT_BYTE] & NVEM_KNOCKOUT_TMR_BITMASK);      /* Timer set up shall be rejected if they are out of range */      if ((ECUKO_TMR_MINVALUE <= DataTmrEcu)       && (BUSKO_TMR_MINVALUE <= DataTmrBus)       && (DID_PARAM_NOT_IMPLEMENTED == DataTmrNVEM)) /* NVEM shall be rejected if !0 is written [KO_915] */      {         KnockOutParameterTmr.ECUKnockout_Tmr = DataTmrEcu;         KnockOutParameterTmr.BusKnockout_Tmr = DataTmrBus;         KnockOutTimerUpdatedUDS = TRUE;         (void)Rte_Call_PS_NvM_BLOCK_KNOCK_OUT_PARAMETER_TMR_SetRamBlockStatus(TRUE);         (void)Rte_Call_PS_NvM_BLOCK_KNOCK_OUT_PARAMETER_TMR_WriteBlock(NULL_PTR);      }      else      {         *ErrorCode = DCM_E_REQUESTOUTOFRANGE;         statusKnockOutTmrWrite = E_NOT_OK;      }   }   else   {      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;      statusKnockOutTmrWrite = E_NOT_OK;   }   return statusKnockOutTmrWrite;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x09F3_KnockOut_test_mode_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 09F3 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x09F3_KnockOut_test_mode_ReadData                                 (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data,&(KnockOutTestBit),DID_09F3_KNOCKOUTTEST_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x09F3_KnockOut_test_mode_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, P2VAR(Dcm_NegativeResponseCodeType, *          AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 09F3 DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x09F3_KnockOut_test_mode_WriteData (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,                             P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{   Std_ReturnType statusKnockOutTest = RTE_E_OK;   if (NULL_PTR != Data)   {      if(KNOCKOUT_TESTBIT_SUPPRESS_VETO >= *Data)      {         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(&(KnockOutTestBit),Data,DID_09F3_KNOCKOUTTEST_SIZE); /* PRQA S 0315 */         (void)Rte_Write_KnockOut_Test_KnockOutTestBit(KnockOutTestBit);      }      else      {         *ErrorCode = DCM_E_REQUESTOUTOFRANGE;         statusKnockOutTest = E_NOT_OK;      }   }   else   {      statusKnockOutTest = E_NOT_OK;      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;   }   return statusKnockOutTest;}/*****************************************************************************//*! * \fn      FUNC(void, RTE_CODE) Idp_Tx_BusKnockOutTmrUDS (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) BusKnockOutTmrUDS_IF) * \brief   Function what gives back the BusKnockout timer value. * \param   [in] BusKnockOutTmrUDS_IF: Variable what will be store the asked value. * \param   [out] BusKnockOutTmrUDS_IF: Variable what will be store the asked value. * \return  None *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(void, RTE_CODE) Idp_Tx_BusKnockOutTmrUDS                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) BusKnockOutTmrUDS_IF) /* PRQA S 3432 */{   if (NULL_PTR != BusKnockOutTmrUDS_IF)   {      *BusKnockOutTmrUDS_IF = KnockOutParameterTmr.BusKnockout_Tmr;   }   return;}/*****************************************************************************//*! * \fn      FUNC(void, RTE_CODE) Idp_Tx_ECUKnockOutTmrUDS (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) ECUKnockTmrUDS_IF) * \brief   Function what gives back the EcuKnockout timer value. * \param   [in] BusKnockOutTmrUDS_IF: Variable what will be store the asked value. * \param   [out] BusKnockOutTmrUDS_IF: Variable what will be store the asked value. * \return  None *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(void, RTE_CODE) Idp_Tx_ECUKnockOutTmrUDS                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) ECUKnockTmrUDS_IF) /* PRQA S 3432 */{   if (NULL_PTR != ECUKnockTmrUDS_IF)   {      *ECUKnockTmrUDS_IF = KnockOutParameterTmr.ECUKnockout_Tmr;   }   return;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x019C_Status_productionmode_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 019C DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x019C_Status_productionmode_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   const uint32 ARRAY_LENGHT_IN_BYTES = 1U;   uint8 Response;   if(NULL_PTR != Data)   {      /* Only Byte2 contains functions, which are affected by production mode. */      if( ((PMode_SigSts_Local == PMode.PMode_SigSts) || (PMode_SigSts_CentralActive == PMode.PMode_SigSts)) &&                    (0x00U != (PMode.PMode_Config[1] & PMODE_FILTER_BYTE2)) )      {         Response = 0x01U;      }      else      {         Response = 0x00U;      }      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(Response), ARRAY_LENGHT_IN_BYTES); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x04FC_Productionmode_deactivate_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 04FC DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x04FC_Productionmode_deactivate_ReadData                               (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   const uint32 ARRAY_LENGHT_IN_BYTES = 3U;   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(PMode.PMode_Config[0U]), ARRAY_LENGHT_IN_BYTES); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x04FC_Productionmode_deactivate_WritedData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, P2VAR(Dcm_NegativeResponseCodeType, *          AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 04FC DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x04FC_Productionmode_deactivate_WritedData                             (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,                             P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{   Std_ReturnType retStatus = RTE_E_OK;   const uint32 ARRAY_LENGHT_IN_BYTES = 3U;   uint8 msg[DID_04FC_PRODUCTIONMODE_DEACTIVATE_INIT_VALUE];   uint8 i;   boolean msgValid = TRUE;   if(NULL_PTR != Data)   {      /* Process the incoming Data. Only 0x000000 is acceptable. */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(&(msg[0U]),Data,ARRAY_LENGHT_IN_BYTES); /* PRQA S 0315 */      for(i = 0U; i<ARRAY_LENGHT_IN_BYTES; i++)      {         if(0x00U != msg[i])         {            msgValid = FALSE;         }      }      if(TRUE == msgValid)      {         /* Reset the configuration */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(&(PMode.PMode_Config[0U]),Data,ARRAY_LENGHT_IN_BYTES); /* PRQA S 0315 */         /* Store the new Data in the NvM immediately */         (void)Rte_Call_PS_NvM_BLOCK_PModeParam_SetRamBlockStatus(TRUE);         (void)Rte_Call_PS_NvM_BLOCK_PModeParam_WriteBlock(NULL_PTR);      }      else      {         /* set NRC 'REQUEST_OUT_OF_RANGE' */         *ErrorCode = DCM_E_REQUESTOUTOFRANGE;         retStatus = E_NOT_OK;      }   }   else   {      retStatus = E_NOT_OK;   }   return retStatus;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x04FE_Productionmode_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 04FE DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x04FE_Productionmode_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   const uint32 ARRAY_LENGHT_IN_BYTES = 3U;   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(PMode.PMode_Config[0U]), ARRAY_LENGHT_IN_BYTES); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x04FE_Productionmode_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, *          P2VAR(Dcm_NegativeResponseCodeType,AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 04FE DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x04FE_Productionmode_WriteData                             (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,                             P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{   Std_ReturnType retStatus = RTE_E_OK;   const uint32 ARRAY_LENGHT_IN_BYTES = 3U;   if(NULL_PTR != Data)   {      if(FALSE == PMode.PMode_MaxDistReached)      {         /* Store the new function configuration */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         TS_MemCpy(&(PMode.PMode_Config[0U]),Data,ARRAY_LENGHT_IN_BYTES); /* PRQA S 0315 */         /* Store in the NvM immediately */         (void)Rte_Call_PS_NvM_BLOCK_PModeParam_SetRamBlockStatus(TRUE);         (void)Rte_Call_PS_NvM_BLOCK_PModeParam_WriteBlock(NULL_PTR);      }      else      {         /* [A: Q-LAH_PMode-21] */         retStatus = E_NOT_OK;         *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;      }   }   else   {      retStatus = E_NOT_OK;   }   return retStatus;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x0410_BootloaderTPBlocksize_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, *          P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 0410 DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" *//*! \misra PRQA 3206 "The function prototype is generated by Tresos, which includes also not used arguments." */FUNC(Std_ReturnType, RTE_CODE) Idp_x0410_BootloaderTPBlocksize_WriteData           (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,           P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */ /* PRQA S 3206 */{   Std_ReturnType retStatus = RTE_E_OK;   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           &(DcmExtCblApplShareData.DID_0410_BootloaderTPBlocksize), Data,DID_0410_BLFTPBLOCK_SIZE);   }   else   {      retStatus = E_NOT_OK;   }  return retStatus;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x02B3_Response_On_Event_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 02B3 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x02B3_Response_On_Event_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{  if(NULL_PTR != Data)  {     /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,     source and destination are the same type" */     TS_MemCpy(Data, &(DID_02B3_ResponseOnEvent),DID_02B3_RESPONSEONEVENT_SIZE); /* PRQA S 0315 */  }  return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A1_VWDataSetVersionNumber_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, *          P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the F1A1 DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1A1_VWDataSetVersionNumber_WriteData                             (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,                             P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */{  Std_ReturnType retStatus = RTE_E_OK;  /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */  uint8 i = 0U; /* PRQA S 2981 */  uint8 msg[DID_F1A1_VWDATASETVERSIONNUMBER_SIZE] = {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE,                                                     DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};  if(NULL_PTR != Data)  {     /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,     source and destination are the same type" */     TS_MemCpy(&(msg[0U]),Data,DID_F1A1_VWDATASETVERSIONNUMBER_SIZE); /* PRQA S 0315 */     if ( (DID_F1A1_DATA_RANGE_LOW_TH >= msg[3U]) || (DID_F1A1_DATA_RANGE_HIGH_TH < msg[3U]) ) /* Range check */     {        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;        retStatus = E_NOT_OK;     }     else     {        for (i = 0U; i < (DID_F1A1_VWDATASETVERSIONNUMBER_SIZE-1U); i++) /* Range check */        {           if ((DID_F1A1_DATA_RANGE_LOW_TH > msg[i]) || (DID_F1A1_DATA_RANGE_HIGH_TH < msg[i]))           {              *ErrorCode = DCM_E_REQUESTOUTOFRANGE;              retStatus = E_NOT_OK;           }        }     }     if (RTE_E_OK == retStatus) /* If the range are correct */     {        /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,        source and destination are the same type" */        TS_MemCpy(&(DID_F1A1_VWDataSetVersionNumber[0U]), Data,DID_F1A1_VWDATASETVERSIONNUMBER_SIZE); /* PRQA S 0315 */        (void) Rte_Call_Idp_PS_NvM_BLOCK_VW_DATA_SET_VERSION_NUMBER_SetRamBlockStatus (TRUE);        (void) Rte_Call_Idp_PS_NvM_BLOCK_VW_DATA_SET_VERSION_NUMBER_WriteBlock (NULL_PTR);     }  }  else  {     retStatus = E_NOT_OK;  }  return retStatus;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1A1_VWDataSetVersionNumber_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F1A1 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1A1_VWDataSetVersionNumber_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{  if(NULL_PTR != Data)  {     /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,     source and destination are the same type" */     TS_MemCpy( Data, &(DID_F1A1_VWDataSetVersionNumber[0U]),DID_F1A1_VWDATASETVERSIONNUMBER_SIZE); /* PRQA S 0315 */  }  return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F182_VWApplicationDataIdentification_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the F182 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F182_VWApplicationDataIdentification_ReadData                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           Data, &(F182_VWApplicationDataIdentification[0U]), DID_F182_VWAPPLDATAIDENTIFICATION_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_F1F4_Bootloader_identification *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function provides the DID 0xF1F4 data for the UDS response. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F1F4_Bootloader_identification                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   /*! \misra PRQA 0310, 3305 "The casting works and intended for the good behavior." */   const t_AdminTable* pAdminTable = (const t_AdminTable*) &CBOOT_ADMNTBL_ADDR_START; /* PRQA S 0310,3305*/   uint8 DID_data[DID_F1F4_BOOTLOADERIDENTIFICATION_SIZE] =   {0x50U, 0x57U, 0x52U, 0x56U, 0x53U, 0x20U, 0x43U,         /* Bootloader identification ID added in hex for ascii */    0x42U, 0x2EU, 0x30U, 0x30U, 0x30U, 0x30U, 0x2DU,    0x2DU, 0x2DU, 0x2DU, 0x20U, 0x2DU, 0x2DU, 0x2DU,    0x2EU, 0x30U, 0x30U, 0x20U, 0x2DU, 0x2DU, 0x2DU, 0x2DU};   /*PWRVS CB.0000---- ---.00 ----*/   uint8 hw_string[HW_STRING_SIZE] = {DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE, DEFAULT_INIT_VALUE};   /* QAC: After the cast operator the "chkprg_is_valid_rom_addr" function checks that   it is pointing to valid memory space. */   if(NULL_PTR != Data)   {      /* copy F1F4 data from Info Table, which includes FLASH_CONFIG_SY */      /* F1F4 format: DID_data[20:18] = FLASH_CONFIG_SY */      (void)Idp_ReadDIDFromInfoTable (pAdminTable, 0xF1F4U, DID_data, DID_F1F4_BOOTLOADERIDENTIFICATION_SIZE);      /* copy bootloader version number from NvM */      /* F1F4 format: DID_data[16:13] = bootloader version number */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           &(DID_data[13U]),           VAG_BL_BlockNvData_store.blockData[1U].DID_F1AB_LogicalBlockVersion,           DID_F1AB_LOGICALBLOCKVERSION_SIZE);      /* detect hardware version */      switch(EcuProdDataParam.HW_VERS_INFO)      {         case HWVERS_BPC3:            hw_string[0U] = 0x42U; /*'B'*/            hw_string[1U] = 0x50U; /*'P'*/            hw_string[2U] = 0x43U; /*'C'*/            hw_string[3U] = 0x33U; /*'3'*/            break;         case HWVERS_BMC2:            hw_string[0U] = 0x42U; /*'B'*/            hw_string[1U] = 0x4DU; /*'M'*/            hw_string[2U] = 0x43U; /*'C'*/            hw_string[3U] = 0x32U; /*'2'*/            break;         default:            hw_string[0U] = 0x2DU; /*'-'*/            hw_string[1U] = 0x2DU; /*'-'*/            hw_string[2U] = 0x2DU; /*'-'*/            hw_string[3U] = 0x2DU; /*'-'*/            break;      }      /* copy hardware version */      /* F1F4 format: DID_data[28:25] = hardware version */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(&(DID_data[25U]), hw_string, HW_STRING_SIZE); /* PRQA S 0315 */      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, DID_data, DID_F1F4_BOOTLOADERIDENTIFICATION_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(void, RTE_CODE) Idp_ProvideProgAttemps *          (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) SuccessProgAttemps, *          P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) ProgThreshold) * \brief   This function provides the programming attempts. * \param   [in] SuccessProgAttemps: Variable what will be store the success programming attempts * \param   [out] ProgThreshold: Variable what will be store the programming attempts threshold * \param   [out] retStatus: The status of the function's execution * \return  None *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(void, RTE_CODE) Idp_ProvideProgAttemps                                 (P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) SuccessProgAttemps, /* PRQA S 3432 */                                P2VAR(uint16, AUTOMATIC, RTE_APPL_DATA) ProgThreshold) /* PRQA S 3432 */{   /* DownGradeProtection incl. */   uint16 IdpSuccessProgAttemps[NUMBER_OF_SOFTWARE_BLOCKS-1U] = {0U,0U,0U,0U};   uint16 IdpProgThreshold[NUMBER_OF_SOFTWARE_BLOCKS-1U] = {0U,0U,0U,0U};   /*! \misra PRQA 2981: variable initialization recommended by Coding Guideline Rule 4.14 */   uint8 blockindex = 0U; /* PRQA S 2981 */   if((NULL_PTR != ProgThreshold) &&      (NULL_PTR != SuccessProgAttemps))   {      for (blockindex = 0U; blockindex < (NUMBER_OF_SOFTWARE_BLOCKS-1U); blockindex++ )      {         IdpSuccessProgAttemps[blockindex] = VAG_BL_BlockNvData_store.blockData[blockindex+1U].SuccProgAttempts;         IdpProgThreshold[blockindex] = VAG_BL_BlockNvData_store.blockData[blockindex+1U].MaxProgAttempts;      }      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           SuccessProgAttemps,           &(IdpSuccessProgAttemps[0U]),           DID_0407_VWLOGICALSWBLCNTOFPRGATT_SIZE);      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           ProgThreshold,            &(IdpProgThreshold[0U]),           DID_0407_VWLOGICALSWBLCNTOFPRGATT_SIZE);   }   return;}/*****************************************************************************//*! * \fn      Idp_F41C_x02CE_OBD_Type_ReadData (uint8* Data) * \brief   This function provides the OBD type data to DID 0xF41C and 0x02CE. * \param   [out] Data: Output value of the DID 0xF41C and 0x02CE, always 5 (Not OBD compliant). * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  RTE_E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_F41C_x02CE_OBD_Type_ReadData         (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /*PRQA S 3432*/{   if (NULL_PTR != Data)   {      *Data = NO_OBD;   }   return RTE_E_OK;}/**********************************************************************************************************************//*! * \fn      FUNC(void, RTE_CODE) Idp_TpBlockSizeDefault (boolean ConditionFulfilled) * \brief   This function provide the default value for the BootloaderTPBlocksize in case of DefaultSession, ECUReset, *          or terminal OFF/ON. * \param   [in]  ConditionFulfilled: Variable what store the condition completion status. * \param   [out] DID_0410_BootloaderTPBlocksize: Variable what will be get the BootloaderTPBlocksize. *//*****************************************************************************/FUNC(void, RTE_CODE) Idp_TpBlockSizeDefault (boolean ConditionFulfilled){   if (TRUE == ConditionFulfilled)   {      DcmExtCblApplShareData.DID_0410_BootloaderTPBlocksize = DID_0410_BOOTLOADERTPBLOCK_DEFAULT_VALUE;   }   return;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) FD00_VsEA_HardwareIdentification_CU_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the FD00 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303495 - Read PWR Production session specific Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) FD00_VsEA_HardwareIdentification_CU_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParam.A5E_CU), DID_FD00_VESA_HARDWAREIDENTIFICATION_CU_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) FD01_VsEA_HardwareIdentification_PU_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the FD01 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303495 - Read PWR Production session specific Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) FD01_VsEA_HardwareIdentification_PU_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParam.A5E_PU), DID_FD01_VESA_HARDWAREIDENTIFICATION_PU_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) FD02_VsEA_HardwareIdentification_FilterBoard_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the FD02 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303495 - Read PWR Production session specific Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) FD02_VsEA_HardwareIdentification_FilterBoard_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           Data,           &(EcuProdDataParam.A5E_EMC_FILTER_HV),            DID_FD02_VESA_HARDWAREIDENTIFICATION_FILTERBOARD_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) FD03_VsEA_HardwareIdentification_IGBT_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the FD03 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303495 - Read PWR Production session specific Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) FD03_VsEA_HardwareIdentification_IGBT_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(EcuProdDataParam.A5E_IGBT), DID_FD03_VESA_HARDWAREIDENTIFICATION_IGBT_SIZE); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) FD04_VsEA_HardwareIdentification_InvCover_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the FD04 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303495 - Read PWR Production session specific Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) FD04_VsEA_HardwareIdentification_InvCover_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           Data,            &(EcuProdDataParam.A5E_INV_COVER),            DID_FD04_VESA_HARDWAREIDENTIFICATION_INVCOVER_SIZE);   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) FEFF_VsEA_MicrocontrollerId_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the FEFF DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303495 - Read PWR Production session specific Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) FEFF_VsEA_MicrocontrollerId_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   uint8 byte_index;   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy( /* PRQA S 0315 */           Data,            (uint32 *)UCB_IFX_ADDRESS,            DID_FEFF_VESA_MICROCONTROLLERID_SIZE);      /* CPU uses 32-bit architecture and little-endian byte ordering so byte swap every 32 bit chunk.       * Assuming AURIX ID takes integer number of words. */      for (byte_index = 0U; DID_FEFF_VESA_MICROCONTROLLERID_SIZE > byte_index; byte_index += (uint8)sizeof(uint32))      {         /*! \misra PRQA 0492 "The array operand is needed for the correct data handling" */         /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,         source and destination are the same type" */         Util_SwapBytes( &Data[byte_index], sizeof(uint32) ); /* PRQA S 0492 */ /* PRQA S 0315 */      }   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x0903_Expected_model_type_ReadData *                                                                        (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) * \brief   This function handles the 0903 DID readability via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \return  Success of operation. * \retval  E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*****************************************************************************//* VWMEB-Inv-303489 - Read Diagnostic Data *//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x0903_Expected_model_type_ReadData                                (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /* PRQA S 3432 */{   if(NULL_PTR != Data)   {      /* copy data into the result buffer */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(Data, &(Idp_ExpectedModelType), 1U); /* PRQA S 0315 */   }   return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(Std_ReturnType, RTE_CODE) Idp_x0903_Expected_model_type_WriteData *          (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data, *          P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) * \brief   This function handles the 0903 DID writing via UDS. * \param   [in] Data: Variable what will be store the needed DID value * \param   [in] ErrorCode: Variable what will be store the ErrorCode if the writing fail * \param   [out] Data: Variable what will be store the needed DID value * \param   [out] retStatus: The status of the function's execution * \retval  RTE_E_OK DID writing is successfull * \retval  E_NOT_OK DID writing is not successfull *//*****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" *//*! \misra PRQA 3206 "The function prototype is generated by Tresos, which includes also not used arguments." */FUNC(Std_ReturnType, RTE_CODE) Idp_x0903_Expected_model_type_WriteData (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Data,      P2VAR(SfdA_DiagNegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode) /* PRQA S 3432 */ /* PRQA S 3206 */{   Std_ReturnType retStatus = RTE_E_OK;   if(NULL_PTR != Data)   {      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(&(Idp_ExpectedModelType),Data,1U); /* PRQA S 0315 */      (void)Rte_Call_PS_NVM_BLOCK_EXPECTED_MODEL_TYPE_SetRamBlockStatus(TRUE);      (void)Rte_Call_PS_NVM_BLOCK_EXPECTED_MODEL_TYPE_WriteBlock(NULL_PTR);      /* Wait for the NvM to write the block */      NvMSm_WaitNvMReady(NvMConf_NvMBlockDescriptor_NVM_BLOCK_EXPECTED_MODEL_TYPE);      (void)Rte_Write_Idp_Expected_model_type_PECInIf_idxCalDatAdp_VW(Idp_ExpectedModelType);   }   else   {      retStatus = E_NOT_OK;   }   return retStatus;}/****************************************************************************** * \brief   Name: Idp_x0448_ProgPrecond_ReadData * \n       Description: Read DID 0448hex * \param   [out] uint8* Data - output array containing DID value - *          Number and list of implemented programming preconditions * \return  Std_ReturnType * \retval  always RTE_E_OK *****************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x0448_ProgPrecond_ReadData         (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /*PRQA S 3432*/{  if(NULL_PTR != Data)  {     /* array subscripting can be applied here, As per AutoSAR config, Data points to an array */     /* PRQA S 0492 ++ */     Data[0U] = MAX_LENGTH_PRECOND_LIST;     Data[1U] = SERV_PRECOND_ENGINE_SPEED;     Data[2U] = IMO_NOT_UNLOCKED;     Data[3U] = SERV_PRECOND_VEHICLE_SPEED;     Data[4U] = SUPPLY_VOLTAGE_TOO_LOW;     Data[5U] = SECURE_STATE;     Data[6U] = SPERRZEIT;     Data[7U] = MAX_NUMBER_OF_PROGRAMMING_EXCEEDED;     Data[8U] = OVERVOLTAGE;     Data[9U] = READINESS_CODE_NOT_RESETTED;     /* PRQA S 0492 -- */  }  return RTE_E_OK;} /* FUNC(Std_ReturnType, RTE_CODE) Idp_x0448_ProgPrecond_ReadData (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) *//*********************************************************************************************************************//*! * \fn      void Idp_x02CF_OBD_class_description_ReadData(uint8* Data) * \brief   This function provides the OBD class description to DID 0x02CF. * \param   [out] Data: Output value of the DID 0x02CF * \return  Success of operation. * \retval  RTE_E_OK - This value is always returned as defined in the AUTOSAR requirements. *//*********************************************************************************************************************//*! \misra PRQA 3432 "Macro expansion does not result in expressionand according to the Coding Guideline rule 4.6 AUTOSAR Compiler Abstraction should be used" */FUNC(Std_ReturnType, RTE_CODE) Idp_x02CF_OBD_class_description_ReadData         (P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) Data) /*PRQA S 3432*/{   if(NULL_PTR != Data)   {      /*! \misra PRQA 0492 "Array subscripting can be applied here, as per AutoSAR config, Data points to an array." */      Data[0U] = X02CF_VERSION_NUMBER; /* PRQA S 0492 */      /*! \misra PRQA 0492 "Array subscripting can be applied here, as per AutoSAR config, Data points to an array." */      Data[1U] = X02CF_OBD_CLASS; /* PRQA S 0492 */   }  return RTE_E_OK;}/*****************************************************************************//*! * \fn      FUNC(void, BSW_CODE) Idp_InitializeAdaptionValue(void) * \brief   Function what send the part of the 0903 DID value to the VW component. * \param   [in] none * \param   [out] none * \return  None *//*****************************************************************************/FUNC(void, BSW_CODE) Idp_InitializeAdaptionValue(void){   /*VW coding value is stored in NVM and must be read and forwarded before the VW component is initialized.*/   /*In the 0x0903_Expected_model_type DID, the 0-3 bits contain the value that should be forwareded to the    *                                                                                 VW component(bytes are swapped)*/   (void)Rte_Write_Idp_Expected_model_type_PECInIf_idxCalDatAdp_VW(Idp_ExpectedModelType);   return;}/*****************************************************************************//*! * \fn      FUNC(void, RTE_CODE) Idp_SetBLKmDate (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Mileage_data,                                                                    P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Date_data) * \brief   Write the current Date and Mileage into the BL nvm ram block * \param   [in] Mileage_data: Variable what contain the mileage. * \param   [in] Date_data: Variable what contain the date. * \param   [out] none * \return  None *//*****************************************************************************/FUNC(void, RTE_CODE) Idp_SetBLKmDate (P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Mileage_data,                                                                    P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) Date_data){   if((NULL_PTR != Mileage_data) && (NULL_PTR != Date_data))   {      /* update ram block */      /*! \misra PRQA 0492 "The array operand is needed for the correct data handling" */      VAG_BL_BlockNvData_store.Diagnose_01_Date_High = Date_data[1U]; /* PRQA S 0492 */      /*! \misra PRQA 0492 "The array operand is needed for the correct data handling" */      VAG_BL_BlockNvData_store.Diagnose_01_Date_Low  = Date_data[0U]; /* PRQA S 0492 */      /*! \misra PRQA 0315  "Implicit conversion unavoidable with memcpy function,      source and destination are the same type" */      TS_MemCpy(&(VAG_BL_BlockNvData_store.KBI_Kilometerstand), Mileage_data, MILAGE_ARRAY_SIZE); /* PRQA S 0315 */   }   return;}/*! \misra PRQA 4800 "This define automatically generated" */#define Idp_STOP_SEC_BSW_CODE_LOCAL  /* PRQA S 4800 */#include "Idp_MemMap.h"/*! @} doxygen end of group definition *//* ********************************************************************** *//* Copyright (C) Valeo Siemens eAutomotive Germany GmbH 2022              *//* All Rights Reserved.  Confidential                                     *//* ********************************************************************** *//*==================[end of file]============================================*/